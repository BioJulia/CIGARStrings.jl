var documenterSearchIndex = {"docs":
[{"page":"Reference","location":"reference/#CIGARStrings.jl-reference","title":"CIGARStrings.jl reference","category":"section","text":""},{"page":"Reference","location":"reference/#CIGARStrings.CIGAR-reference","title":"CIGARStrings.CIGAR","category":"type","text":"CIGAR\n\nA CIGAR string represents the sequence of insertions, matches and deletions that comprise a pairwise alignment. Construct a CIGAR from any object x where MemoryView(x) returns a MemoryView{UInt8}, i.e. any memory-backed bytearray, or string.\n\nUse CIGARStrings.try_parse to attempt to parse a CIGAR string without throwing an exception if the data is invalid.\n\nSee also: CIGARElement\n\nExtended help\n\nCIGAR strings are sequences of CIGARElement, from the 5' to the 3' of the query (or N- to C-terminal for amino acids). CIGAR strings comprise the entire query, i.e. the sum of lengths of elements with the XMI=SH operations equals the length of the query.\n\nFor example, the query AGCGTAGCACACC that aligns from query base 5 and ref base 1002, like this:\n\nQ: 5    TAG--CACACC   13\nR: 1002 TAGGACAC-CC 1011\n\nIs summarized by the CIGAR 4S3M2D3M1I2M. The operations HX=PN are more rarely used, see CIGAROp for a description of the operations.\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.CIGARElement-reference","title":"CIGARStrings.CIGARElement","category":"type","text":"CIGARElement(op::CIGAROp, len::Integer)\n\nType representing a single element in a CIGAR string, consisting of a CIGAROp and a length. For example, in 15S198M1D15M, the four elements are 15S, 198M, 1D, and 15M. Access the operation and the length with the properties .op and .len. Note that currently, the largest supported length is 268435455. Operations cannot have length zero.\n\nSee also: CIGAR, CIGAROp\n\nExamples\n\njulia> e = CIGARElement(OP_X, 3)\nCIGARElement(OP_X, 3)\n\njulia> e.len\n3\n\njulia> e.op\nOP_X\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.CIGAROp-reference","title":"CIGARStrings.CIGAROp","category":"type","text":"CIGAROp\n\n1-byte primitive type representing a CIGAR operation. Module-level constants for each value of this type are exported, e.g. OP_M.\n\nA CIGAROp is guaranteed to be a 1-byte primitive with the same bitwise representation as a UInt8 with the value given as N in the table below, e.g. reinterpret(UInt8, OP_I) === 0x01.\n\nThe Consumes entry below signifies if the operation advances the position in the query (Q), the reference (R) and the alignment (A). E.g. if the CIGARElement 9D begins at query, ref, aln positions (A, B, C), then the positions are (A, B+9, C+9) after. \n\nN Consumes Variable Char Description\n0 Q R A OP_M M Alignment match or mismatch\n1 Q   A OP_I I Insertion relative to the reference\n2 R A OP_D D Deletion relative to the reference\n3 R OP_N N Reference skipped from the alignment (usually an intron)\n4 Q OP_S S Soft clip (semantically identical to hard clip)\n5 Q OP_H H Hard clip (semantically identical to soft clip)\n6  OP_P P Padding, position not present in query or reference\n7 Q R A OP_Eq = Alignment match, not mismatch\n8 Q R A OP_X X Alignment mismatch\n\nSee also: CIGARElement\n\nExtended help\n\nM means a match or a mismatch. By default, most programs will emit M instead of X or =, since the important part of the CIGAR is where the insertions and deletions are placed. To determine which bases in an M are matches and mismatches, the two sequences can be compared, base-wise.\nN means that the region is spans an intron, which means the query sequence is deleted, but not due to an actual deletion (which would be a D operation). It can also be used for other uses where the reference bases is missing for another reason than a deletion, if such a use case is found.\nS and H are semantically identical. They both signify the end(s) of the query sequence which are not part of the alignment. They differ only in whether the clipped bases are written in the SEQ field of a SAM record. Typically, hard-clipped bases are present as soft clipped bases in another record, such that writing them in both records would be wasteful.\nP is only used for a multiple sequence alignment. If a third sequence contains an insertion relative to both the query and the reference, the query has a P at this position, indicating it's present in neither the query nor reference.\nMost alignments only contain the operations M, I, D, S.\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.Translation-reference","title":"CIGARStrings.Translation","category":"type","text":"Translation(kind::TranslationKind, pos::Int)\n\nThe result of translating from a position in the coordinate system of the  query / reference / alignment to a position in one of the others. This type contains two documented properies: kind::TranslationKind and pos::Int.\n\nIf the resulting position is outside the target coordinate, .kind == outside and pos == 0\nIf the position maps to a non-gap symbol in the other coodinate system, .kind == pos, and the position is the pos'd symbol in the target coordinate system.\nIf the position maps to a gap, pos is the position of the symbol before the gap, and kind == gap. When translating to the aln coordinate system, the kind is never gap.\n\nSee also: CIGARStrings.TranslationKind\n\nExamples:\n\njulia> c = CIGAR(\"2M3D2M2I1M\");\n\njulia> for i in 0:8\n           refpos = query_to_ref(c, i)\n           println(refpos.pos, ' ', refpos.kind)\n       end\n0 outside\n1 pos\n2 pos\n6 pos\n7 pos\n7 gap\n7 gap\n8 pos\n0 outside\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.TranslationKind-reference","title":"CIGARStrings.TranslationKind","category":"type","text":"TranslationKind\n\nThis enum has values outside, pos and gap. It represents the result of translating a position between query, reference and alignment.\n\nIf outside, the input position translates to a position outside the alignment\nIf pos, the input position corresponds to a non-gap symbol in the alignment\nIf gap, the input position maps to a gap.\n\nSee also: Translation\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.CIGARError-reference","title":"CIGARStrings.CIGARError","category":"type","text":"CIGARError\n\nException kind thrown by the package CIGARStrings. CIGARErrors contain two properties: .kind, returning a CIGARErrorType, and .index, returning an Int, pointing to the approximate byte index where the exception was encountered.\n\nThe kind and pos are stable API, in the sense that e.g. an integer overflow at position 55 will always be represented by a CIGARError(55, CIGARStrings.Errors.IntegerOverflow). However, the same invalid CIGAR string may produce multiple different errors, and which error is produced in that case is NOT stable API, because that depends on specifics parsing internals.\n\njulia> ce = CIGARStrings.try_parse(CIGAR, \"15M9\");\n\njulia> ce.index\n4\n\njulia> ce.kind\nTruncated::CIGARErrorType = 0x05\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.Errors.CIGARErrorType-reference","title":"CIGARStrings.Errors.CIGARErrorType","category":"type","text":"CIGARErrorType\n\nSingle-byte enum representing the different kind of errors returned or thrown by the package CIGARStrings. This currently implemented list of error kinds is not exhaustive, in that more could be added in minor versions of this package.\n\nSee also: CIGARError\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.try_parse-reference","title":"CIGARStrings.try_parse","category":"function","text":"try_parse(::Type{CIGAR}, x)::Union{CIGAR, CIGARError}\n\nCast x to a MemoryView{UInt8}, and try parsing a CIGAR from it. If the parsing is unsuccessful, return a CIGARError\n\nExamples\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"2S1M9I\");\n\njulia> c isa CIGAR # success\ntrue\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"1S7H9M1S\");\n\njulia> c.kind\nInvalidHardClip::CIGARErrorType = 0x03\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_M","title":"CIGARStrings.OP_M","category":"constant","text":"'M': Alignment match or mismatch\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_I","title":"CIGARStrings.OP_I","category":"constant","text":"'I': Insertion relative to the reference\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_D","title":"CIGARStrings.OP_D","category":"constant","text":"'D': Deletion relative to the reference\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_S","title":"CIGARStrings.OP_S","category":"constant","text":"'S': Soft clip (clipped sequence present in query)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_H","title":"CIGARStrings.OP_H","category":"constant","text":"'H': Hard clip (clipped sequence not present in query)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_N","title":"CIGARStrings.OP_N","category":"constant","text":"'N': Region skipped from the reference (usually an intron)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_P","title":"CIGARStrings.OP_P","category":"constant","text":"'P': Padding\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_X","title":"CIGARStrings.OP_X","category":"constant","text":"'X': Alignment mismatch\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.OP_Eq","title":"CIGARStrings.OP_Eq","category":"constant","text":"'=': Alignment match, not mismatch\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.ref_length","title":"CIGARStrings.ref_length","category":"function","text":"ref_length(::CIGAR)::Int\n\nGet the number of biosymbols in the reference of the CIGAR. This is the same as the lengths of all CIGARElements of type M, D, N, = and X.\n\nSee also: query_length, aln_length\n\nExample\n\njulia> ref_length(CIGAR(\"1S5M2D6M2I5M\"))\n18\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.query_length","title":"CIGARStrings.query_length","category":"function","text":"query_length(::CIGAR)::Int\n\nGet the number of biosymbols in the query of the CIGAR. This is the same as the lengths of all CIGARElements of type M, I, S, H, = and X.\n\nSee also: ref_length, aln_length\n\nExample\n\njulia> query_length(CIGAR(\"1S5M2D6M2I5M\"))\n19\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.aln_length","title":"CIGARStrings.aln_length","category":"function","text":"aln_length(::CIGAR)::Int\n\nGet the number of biosymbols spanned by the alignment of the CIGAR. Clips, padding and skips are not part of the alignment, but still part of the CIGAR. Therefore, the alignment length is the same as the lengths of all CIGARElements of type M, I, D, = and X.\n\nSee also: query_length, ref_length\n\nExample\n\njulia> aln_length(CIGAR(\"1S5M2D6M2I5M\"))\n20\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.aln_identity","title":"CIGARStrings.aln_identity","category":"function","text":"aln_identity(::CIGAR, mismatches::Int)::Float64\n\nCompute the alignment identity of the CIGAR, computed as the number of matches (not mismtches) divided by alignment length. Since the CIGAR itself may not provide information about the precise number of mismatches, the amount of mismatches is an argument. The result is always in [0.0, 1.0].\n\nExample\n\njulia> aln_identity(CIGAR(\"3M1D3M1I2M\"), 2)\n0.6\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.query_to_ref","title":"CIGARStrings.query_to_ref","category":"function","text":"query_to_ref(x::CIGAR, pos::Int)::Int\n\nGet the 1-based reference position aligning to query position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> query_to_ref(c, 4)\nTranslation(pos, 6)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.query_to_aln","title":"CIGARStrings.query_to_aln","category":"function","text":"query_to_aln(x::CIGAR, pos::Int)::Int\n\nGet the 1-based alignment position aligning to query position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> query_to_aln(c, 8)\nTranslation(pos, 10)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.ref_to_query","title":"CIGARStrings.ref_to_query","category":"function","text":"ref_to_query(x::CIGAR, pos::Int)::Int\n\nGet the 1-based query position aligning to reference position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> ref_to_query(c, 7)\nTranslation(pos, 9)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.ref_to_aln","title":"CIGARStrings.ref_to_aln","category":"function","text":"ref_to_aln(x::CIGAR, pos::Int)::Int\n\nGet the 1-based alignment position aligning to reference position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> ref_to_aln(c, 7)\nTranslation(pos, 11)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.aln_to_query","title":"CIGARStrings.aln_to_query","category":"function","text":"aln_to_query(x::CIGAR, pos::Int)::Int\n\nGet the 1-based query position aligning to alignment position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> aln_to_query(c, 10)\nTranslation(pos, 8)\n\n\n\n\n\n"},{"page":"Reference","location":"reference/#CIGARStrings.aln_to_ref","title":"CIGARStrings.aln_to_ref","category":"function","text":"aln_to_ref(x::CIGAR, pos::Int)::Int\n\nGet the 1-based reference position aligning to alignment position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> aln_to_ref(c, 9)\nTranslation(gap, 6)\n\n\n\n\n\n"},{"page":"Home","location":"#CIGARStrings.jl","title":"CIGARStrings.jl","category":"section","text":""},{"page":"Home","location":"","title":"Home","category":"page","text":"CIGARStrings.jl provide functionality for parsing and working with Concise Idiosyncratic Gapped Alignment Report - or CIGAR - strings. CIGARs were popularized by the SAM format, and are a compact run length encoding notation to represent pairwise alignments. They can be found in the SAM, BAM, PAF, and GFA formats."},{"page":"Home","location":"","title":"Home","category":"page","text":"For example, the following pairwise alignment of a query to a reference:"},{"page":"Home","location":"","title":"Home","category":"page","text":"    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC"},{"page":"Home","location":"","title":"Home","category":"page","text":"Can be represented by the CIGAR 5M3D2M2I3M, representing:"},{"page":"Home","location":"","title":"Home","category":"page","text":"5 matches/mismatches\nThen, 3 deletions\nThen, 2 matches/mismatches\nThen, 2 insertions\nFinally, 3 matches/mismatches."},{"page":"Home","location":"","title":"Home","category":"page","text":"A CIGAR strings is always written in terms of the query, and not the reference. "},{"page":"Home","location":"#Individual-alignment-operations","title":"Individual alignment operations","category":"section","text":""},{"page":"Home","location":"","title":"Home","category":"page","text":"One run of identical alignment operations, e.g. \"5 matches/mismatches\" are represented by a single CIGARElement. Conceptually, a CIGARElement is an alignment operation (represented by a CIGAROp) and a length:"},{"page":"Home","location":"#CIGARStrings.CIGARElement","title":"CIGARStrings.CIGARElement","category":"type","text":"CIGARElement(op::CIGAROp, len::Integer)\n\nType representing a single element in a CIGAR string, consisting of a CIGAROp and a length. For example, in 15S198M1D15M, the four elements are 15S, 198M, 1D, and 15M. Access the operation and the length with the properties .op and .len. Note that currently, the largest supported length is 268435455. Operations cannot have length zero.\n\nSee also: CIGAR, CIGAROp\n\nExamples\n\njulia> e = CIGARElement(OP_X, 3)\nCIGARElement(OP_X, 3)\n\njulia> e.len\n3\n\njulia> e.op\nOP_X\n\n\n\n\n\n"},{"page":"Home","location":"#CIGARStrings.CIGAROp","title":"CIGARStrings.CIGAROp","category":"type","text":"CIGAROp\n\n1-byte primitive type representing a CIGAR operation. Module-level constants for each value of this type are exported, e.g. OP_M.\n\nA CIGAROp is guaranteed to be a 1-byte primitive with the same bitwise representation as a UInt8 with the value given as N in the table below, e.g. reinterpret(UInt8, OP_I) === 0x01.\n\nThe Consumes entry below signifies if the operation advances the position in the query (Q), the reference (R) and the alignment (A). E.g. if the CIGARElement 9D begins at query, ref, aln positions (A, B, C), then the positions are (A, B+9, C+9) after. \n\nN Consumes Variable Char Description\n0 Q R A OP_M M Alignment match or mismatch\n1 Q   A OP_I I Insertion relative to the reference\n2 R A OP_D D Deletion relative to the reference\n3 R OP_N N Reference skipped from the alignment (usually an intron)\n4 Q OP_S S Soft clip (semantically identical to hard clip)\n5 Q OP_H H Hard clip (semantically identical to soft clip)\n6  OP_P P Padding, position not present in query or reference\n7 Q R A OP_Eq = Alignment match, not mismatch\n8 Q R A OP_X X Alignment mismatch\n\nSee also: CIGARElement\n\nExtended help\n\nM means a match or a mismatch. By default, most programs will emit M instead of X or =, since the important part of the CIGAR is where the insertions and deletions are placed. To determine which bases in an M are matches and mismatches, the two sequences can be compared, base-wise.\nN means that the region is spans an intron, which means the query sequence is deleted, but not due to an actual deletion (which would be a D operation). It can also be used for other uses where the reference bases is missing for another reason than a deletion, if such a use case is found.\nS and H are semantically identical. They both signify the end(s) of the query sequence which are not part of the alignment. They differ only in whether the clipped bases are written in the SEQ field of a SAM record. Typically, hard-clipped bases are present as soft clipped bases in another record, such that writing them in both records would be wasteful.\nP is only used for a multiple sequence alignment. If a third sequence contains an insertion relative to both the query and the reference, the query has a P at this position, indicating it's present in neither the query nor reference.\nMost alignments only contain the operations M, I, D, S.\n\n\n\n\n\n"},{"page":"Home","location":"#CIGARs","title":"CIGARs","category":"section","text":""},{"page":"Home","location":"","title":"Home","category":"page","text":"The CIGAR strings themselves are represented by the CIGAR type, which is backed by a MemoryView (from the MemoryViews.jl package). CIGARs can be constructed from most memory-backed, contiguous byte vectors, and are validated upon construction:"},{"page":"Home","location":"","title":"Home","category":"page","text":"julia> CIGAR(\"2M1D3M\")\nCIGAR(\"2M1D3M\")\n\njulia> CIGAR(\"1M1W1S\")\nERROR: Error around byte 4: Invalid operation. Possible values are \"MIDNSHP=X\".\n[...]"},{"page":"Home","location":"#CIGARStrings.CIGAR","title":"CIGARStrings.CIGAR","category":"type","text":"CIGAR\n\nA CIGAR string represents the sequence of insertions, matches and deletions that comprise a pairwise alignment. Construct a CIGAR from any object x where MemoryView(x) returns a MemoryView{UInt8}, i.e. any memory-backed bytearray, or string.\n\nUse CIGARStrings.try_parse to attempt to parse a CIGAR string without throwing an exception if the data is invalid.\n\nSee also: CIGARElement\n\nExtended help\n\nCIGAR strings are sequences of CIGARElement, from the 5' to the 3' of the query (or N- to C-terminal for amino acids). CIGAR strings comprise the entire query, i.e. the sum of lengths of elements with the XMI=SH operations equals the length of the query.\n\nFor example, the query AGCGTAGCACACC that aligns from query base 5 and ref base 1002, like this:\n\nQ: 5    TAG--CACACC   13\nR: 1002 TAGGACAC-CC 1011\n\nIs summarized by the CIGAR 4S3M2D3M1I2M. The operations HX=PN are more rarely used, see CIGAROp for a description of the operations.\n\n\n\n\n\n"},{"page":"Home","location":"","title":"Home","category":"page","text":"CIGARs are iterable, and returns its CIGARElements, in order:"},{"page":"Home","location":"","title":"Home","category":"page","text":"julia> collect(CIGAR(\"2M1D3M\"))\n3-element Vector{CIGARElement}:\n CIGARElement(OP_M, 2)\n CIGARElement(OP_D, 1)\n CIGARElement(OP_M, 3)"},{"page":"Home","location":"","title":"Home","category":"page","text":"They can be converted back to strings using string(::CIGAR), or printed into an IO, in which case their normal string representation is recovered:"},{"page":"Home","location":"","title":"Home","category":"page","text":"julia> c = CIGAR(\"2M1D3M\");\n\njulia> string(c)\n\"2M1D3M\"\n\njulia> io = IOBuffer(); print(io, c); String(take!(io))\n\"2M1D3M\""},{"page":"Home","location":"#Basic-information-about-a-CIGAR","title":"Basic information about a CIGAR","category":"section","text":""},{"page":"Home","location":"","title":"Home","category":"page","text":"The reference, query and alignment length can be obtained with the functions ref_length, query_length and aln_length."},{"page":"Home","location":"","title":"Home","category":"page","text":"In the alignment below, represented as 5M3D2M2I3M, the query length is 12, since there are 12 query symbols, the reference length is 13, and the alignment length is 15."},{"page":"Home","location":"","title":"Home","category":"page","text":"    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC"},{"page":"Home","location":"","title":"Home","category":"page","text":"We always have aln_length(c) ≥ max(query_length(c), ref_length(c))"},{"page":"Home","location":"","title":"Home","category":"page","text":"julia> c = CIGAR(\"5M3D2M2I3M\");\n\njulia> ref_length(c)\n13\n\njulia> query_length(c)\n12\n\njulia> aln_length(c)\n15"},{"page":"Home","location":"","title":"Home","category":"page","text":"The alignment identity (number of matches, not mismatches divided by alignment length) can be obtained with aln_identity. Since the number of mismatches may not be known from the CIGAR itself (i.e. \"100M\" could have anywhere from 0 to 100 mismatches), the mismatches is passed in as an argument:"},{"page":"Home","location":"","title":"Home","category":"page","text":"julia> aln_identity(CIGAR(\"3M1D3M1I2M\"), 2)\n0.6"},{"page":"Home","location":"#Position-translation","title":"Position translation","category":"section","text":""},{"page":"Home","location":"","title":"Home","category":"page","text":"Sometimes it may be necessary to answer questions of the form \"which reference position does query position 8 align to?\"."},{"page":"Home","location":"","title":"Home","category":"page","text":"As an example, consider the alignment below. The query position (QP), reference position (RP) and alignment position (AP) are also written in this alignment."},{"page":"Home","location":"","title":"Home","category":"page","text":"    QP:12345   6789012\n\n    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC\n\n    RP:1234567890  123\n    AP:123456789012345"},{"page":"Home","location":"","title":"Home","category":"page","text":"We can see that query position 6 aligns to reference position 9, which is also alignment position 9."},{"page":"Home","location":"","title":"Home","category":"page","text":"These position translations can be obtained using the functions query_to_ref, query_to_aln, ref_to_query, ref_to_aln, aln_to_query and aln_to_ref. They return a Translation object that contains two properties: .pos and .kind."},{"page":"Home","location":"","title":"Home","category":"page","text":"When a position translation has a straightforward answer, the .kind property is CIGARStrings.pos, and the .pos field is the corresponding position:"},{"page":"Home","location":"","title":"Home","category":"page","text":"julia> c = CIGAR(\"4M3D2M2I3M\"); # alignment above\n\njulia> query_to_ref(c, 6)\nTranslation(pos, 9)\n\njulia> aln_to_query(c, 9)\nTranslation(pos, 6)"},{"page":"Home","location":"#CIGARStrings.Translation","title":"CIGARStrings.Translation","category":"type","text":"Translation(kind::TranslationKind, pos::Int)\n\nThe result of translating from a position in the coordinate system of the  query / reference / alignment to a position in one of the others. This type contains two documented properies: kind::TranslationKind and pos::Int.\n\nIf the resulting position is outside the target coordinate, .kind == outside and pos == 0\nIf the position maps to a non-gap symbol in the other coodinate system, .kind == pos, and the position is the pos'd symbol in the target coordinate system.\nIf the position maps to a gap, pos is the position of the symbol before the gap, and kind == gap. When translating to the aln coordinate system, the kind is never gap.\n\nSee also: CIGARStrings.TranslationKind\n\nExamples:\n\njulia> c = CIGAR(\"2M3D2M2I1M\");\n\njulia> for i in 0:8\n           refpos = query_to_ref(c, i)\n           println(refpos.pos, ' ', refpos.kind)\n       end\n0 outside\n1 pos\n2 pos\n6 pos\n7 pos\n7 gap\n7 gap\n8 pos\n0 outside\n\n\n\n\n\n"},{"page":"Home","location":"#CIGARStrings.TranslationKind","title":"CIGARStrings.TranslationKind","category":"type","text":"TranslationKind\n\nThis enum has values outside, pos and gap. It represents the result of translating a position between query, reference and alignment.\n\nIf outside, the input position translates to a position outside the alignment\nIf pos, the input position corresponds to a non-gap symbol in the alignment\nIf gap, the input position maps to a gap.\n\nSee also: Translation\n\n\n\n\n\n"},{"page":"Home","location":"#Errors-and-error-recovery","title":"Errors and error recovery","category":"section","text":""},{"page":"Home","location":"","title":"Home","category":"page","text":"CIGARStrings.jl allows you to parse a poential CIGAR string without throwing an exception if the data is invalid, using the function CIGARStrings.try_parse."},{"page":"Home","location":"#CIGARStrings.CIGARError","title":"CIGARStrings.CIGARError","category":"type","text":"CIGARError\n\nException kind thrown by the package CIGARStrings. CIGARErrors contain two properties: .kind, returning a CIGARErrorType, and .index, returning an Int, pointing to the approximate byte index where the exception was encountered.\n\nThe kind and pos are stable API, in the sense that e.g. an integer overflow at position 55 will always be represented by a CIGARError(55, CIGARStrings.Errors.IntegerOverflow). However, the same invalid CIGAR string may produce multiple different errors, and which error is produced in that case is NOT stable API, because that depends on specifics parsing internals.\n\njulia> ce = CIGARStrings.try_parse(CIGAR, \"15M9\");\n\njulia> ce.index\n4\n\njulia> ce.kind\nTruncated::CIGARErrorType = 0x05\n\n\n\n\n\n"},{"page":"Home","location":"#CIGARStrings.Errors.CIGARErrorType","title":"CIGARStrings.Errors.CIGARErrorType","category":"type","text":"CIGARErrorType\n\nSingle-byte enum representing the different kind of errors returned or thrown by the package CIGARStrings. This currently implemented list of error kinds is not exhaustive, in that more could be added in minor versions of this package.\n\nSee also: CIGARError\n\n\n\n\n\n"},{"page":"Home","location":"#CIGARStrings.try_parse","title":"CIGARStrings.try_parse","category":"function","text":"try_parse(::Type{CIGAR}, x)::Union{CIGAR, CIGARError}\n\nCast x to a MemoryView{UInt8}, and try parsing a CIGAR from it. If the parsing is unsuccessful, return a CIGARError\n\nExamples\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"2S1M9I\");\n\njulia> c isa CIGAR # success\ntrue\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"1S7H9M1S\");\n\njulia> c.kind\nInvalidHardClip::CIGARErrorType = 0x03\n\n\n\n\n\n"}]
}

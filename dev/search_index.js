var documenterSearchIndex = {"docs":
[{"title":"CIGARStrings.jl reference","page":"Reference","location":"reference/#CIGARStrings.jl-reference","category":"section","text":""},{"title":"CIGARStrings.CIGAR","page":"Reference","location":"reference/#CIGARStrings.CIGAR-reference","category":"type","text":"CIGAR <: AbstractCIGAR\n\nA CIGAR string represents the sequence of insertions, matches and deletions that comprise a pairwise alignment. Construct a CIGAR from any object x where MemoryView(x) returns a MemoryView{UInt8}, i.e. any memory-backed bytearray, or string.\n\nUse CIGARStrings.try_parse to attempt to parse a CIGAR string without throwing an exception if the data is invalid.\n\nSee also: CIGARElement\n\nExtended help\n\nCIGAR strings are sequences of CIGARElement, from the 5' to the 3' of the query (or N- to C-terminal for amino acids). CIGAR strings comprise the entire query, i.e. the sum of lengths of elements with the XMI=SH operations equals the length of the query.\n\nFor example, the query AGCGTAGCACACC that aligns from query base 5 and ref base 1002, like this:\n\nQ: 5    TAG--CACACC   13\nR: 1002 TAGGACAC-CC 1011\n\nIs summarized by the CIGAR 4S3M2D3M1I2M. The operations HX=PN are more rarely used, see CIGAROp for a description of the operations.\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGARElement","page":"Reference","location":"reference/#CIGARStrings.CIGARElement-reference","category":"type","text":"CIGARElement(op::CIGAROp, len::Integer)\n\nType representing a single element in a CIGAR string, consisting of a CIGAROp and a length. For example, in 15S198M1D15M, the four elements are 15S, 198M, 1D, and 15M. Access the operation and the length with the properties .op and .len. Note that currently, the largest supported length is 268435455. Operations cannot have length zero.\n\nSee also: CIGAR, CIGAROp\n\nExamples\n\njulia> e = CIGARElement(OP_X, 3)\nCIGARElement(OP_X, 3)\n\njulia> e.len\n3\n\njulia> e.op\nOP_X\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGAROp","page":"Reference","location":"reference/#CIGARStrings.CIGAROp-reference","category":"type","text":"CIGAROp\n\n1-byte primitive type representing a CIGAR operation. Module-level constants for each value of this type are exported, e.g. OP_M.\n\nA CIGAROp is guaranteed to be a 1-byte primitive with the same bitwise representation as a UInt8 with the value given as N in the table below, e.g. reinterpret(UInt8, OP_I) === 0x01.\n\nThe Consumes entry below signifies if the operation advances the position in the query (Q), the reference (R) and the alignment (A). E.g. if the CIGARElement 9D begins at query, ref, aln positions (A, B, C), then the positions are (A, B+9, C+9) after. \n\nN Consumes Variable Char Description\n0 Q R A OP_M M Alignment match or mismatch\n1 Q   A OP_I I Insertion relative to the reference\n2 R A OP_D D Deletion relative to the reference\n3 R OP_N N Reference skipped from the alignment (usually an intron)\n4 Q OP_S S Soft clip (semantically identical to hard clip)\n5 Q OP_H H Hard clip (semantically identical to soft clip)\n6  OP_P P Padding, position not present in query or reference\n7 Q R A OP_Eq = Alignment match, not mismatch\n8 Q R A OP_X X Alignment mismatch\n\nSee also: CIGARElement\n\nExtended help\n\nM means a match or a mismatch. By default, most programs will emit M instead of X or =, since the important part of the CIGAR is where the insertions and deletions are placed. To determine which bases in an M are matches and mismatches, the two sequences can be compared, base-wise.\nN means that the region is spans an intron, which means the query sequence is deleted, but not due to an actual deletion (which would be a D operation). It can also be used for other uses where the reference bases is missing for another reason than a deletion, if such a use case is found.\nS and H are semantically identical. They both signify the end(s) of the query sequence which are not part of the alignment. They differ only in whether the clipped bases are written in the SEQ field of a SAM record. Typically, hard-clipped bases are present as soft clipped bases in another record, such that writing them in both records would be wasteful.\nP is only used for a multiple sequence alignment. If a third sequence contains an insertion relative to both the query and the reference, the query has a P at this position, indicating it's present in neither the query nor reference.\nMost alignments only contain the operations M, I, D, S.\n\n\n\n\n\n"},{"title":"CIGARStrings.Translation","page":"Reference","location":"reference/#CIGARStrings.Translation-reference","category":"type","text":"Translation(kind::TranslationKind, pos::Int)\n\nThe result of translating from a position in the coordinate system of the  query / reference / alignment to a position in one of the others. This type contains two documented properies: kind::TranslationKind and pos::Int.\n\nIf the resulting position is outside the target coordinate, .kind == outside and pos == 0\nIf the position maps to a non-gap symbol in the other coodinate system, .kind == pos, and the position is the pos'd symbol in the target coordinate system.\nIf the position maps to a gap, pos is the position of the symbol before the gap, and kind == gap. When translating to the aln coordinate system, the kind is never gap.\n\nSee also: CIGARStrings.TranslationKind\n\nExamples:\n\njulia> c = CIGAR(\"2M3D2M2I1M\");\n\njulia> for i in 0:8\n           refpos = query_to_ref(c, i)\n           println(refpos.pos, ' ', refpos.kind)\n       end\n0 outside\n1 pos\n2 pos\n6 pos\n7 pos\n7 gap\n7 gap\n8 pos\n0 outside\n\n\n\n\n\n"},{"title":"CIGARStrings.TranslationKind","page":"Reference","location":"reference/#CIGARStrings.TranslationKind-reference","category":"type","text":"TranslationKind\n\nThis enum has values outside, pos and gap. It represents the result of translating a position between query, reference and alignment.\n\nIf outside, the input position translates to a position outside the alignment\nIf pos, the input position corresponds to a non-gap symbol in the alignment\nIf gap, the input position maps to a gap.\n\nSee also: Translation\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGARError","page":"Reference","location":"reference/#CIGARStrings.CIGARError-reference","category":"type","text":"CIGARError\n\nException kind thrown by the package CIGARStrings. CIGARErrors contain two properties: .kind, returning a CIGARErrorType, and .index, returning an Int, pointing to the approximate byte index where the exception was encountered.\n\nThe kind and pos are stable API, in the sense that e.g. an integer overflow at position 55 will always be represented by a CIGARError(55, CIGARStrings.Errors.IntegerOverflow). However, the same invalid CIGAR string may produce multiple different errors, and which error is produced in that case is NOT stable API, because that depends on specifics parsing internals.\n\njulia> ce = CIGARStrings.try_parse(CIGAR, \"15M9\");\n\njulia> ce.index\n4\n\njulia> ce.kind\nTruncated::CIGARErrorType = 0x05\n\n\n\n\n\n"},{"title":"CIGARStrings.Errors.CIGARErrorType","page":"Reference","location":"reference/#CIGARStrings.Errors.CIGARErrorType-reference","category":"type","text":"CIGARErrorType\n\nSingle-byte enum representing the different kind of errors returned or thrown by the package CIGARStrings. This currently implemented list of error kinds is not exhaustive, in that more could be added in minor versions of this package.\n\nSee also: CIGARError\n\n\n\n\n\n"},{"title":"CIGARStrings.try_parse","page":"Reference","location":"reference/#CIGARStrings.try_parse-reference","category":"function","text":"try_parse(::Type{CIGAR}, x)::Union{CIGAR, CIGARError}\n\nCast x to a MemoryView{UInt8}, and try parsing a CIGAR from it. If the parsing is unsuccessful, return a CIGARError\n\nExamples\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"2S1M9I\");\n\njulia> c isa CIGAR # success\ntrue\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"1S7H9M1S\");\n\njulia> c.kind\nInvalidHardClip::CIGARErrorType = 0x03\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_M","page":"Reference","location":"reference/#CIGARStrings.OP_M","category":"constant","text":"'M': Alignment match or mismatch\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_I","page":"Reference","location":"reference/#CIGARStrings.OP_I","category":"constant","text":"'I': Insertion relative to the reference\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_D","page":"Reference","location":"reference/#CIGARStrings.OP_D","category":"constant","text":"'D': Deletion relative to the reference\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_S","page":"Reference","location":"reference/#CIGARStrings.OP_S","category":"constant","text":"'S': Soft clip (clipped sequence present in query)\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_H","page":"Reference","location":"reference/#CIGARStrings.OP_H","category":"constant","text":"'H': Hard clip (clipped sequence not present in query)\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_N","page":"Reference","location":"reference/#CIGARStrings.OP_N","category":"constant","text":"'N': Region skipped from the reference (usually an intron)\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_P","page":"Reference","location":"reference/#CIGARStrings.OP_P","category":"constant","text":"'P': Padding\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_X","page":"Reference","location":"reference/#CIGARStrings.OP_X","category":"constant","text":"'X': Alignment mismatch\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_Eq","page":"Reference","location":"reference/#CIGARStrings.OP_Eq","category":"constant","text":"'=': Alignment match, not mismatch\n\n\n\n\n\n"},{"title":"CIGARStrings.PositionMapper","page":"Reference","location":"reference/#CIGARStrings.PositionMapper","category":"type","text":"PositionMapper{Params...}\n\nPublic struct returned by pos_to_pos(..., pos) when !isa(pos, Integer). This type may be referred to in stable code, but its API is defined by pos_to_pos\n\nSee also: pos_to_pos\n\n\n\n\n\n"},{"title":"CIGARStrings.query","page":"Reference","location":"reference/#CIGARStrings.query","category":"function","text":"Coordinate system representing the 1-based index in the query sequence\n\n\n\n\n\n"},{"title":"CIGARStrings.ref","page":"Reference","location":"reference/#CIGARStrings.ref","category":"function","text":"Coordinate system representing the 1-based index in the reference sequence\n\n\n\n\n\n"},{"title":"CIGARStrings.aln","page":"Reference","location":"reference/#CIGARStrings.aln","category":"function","text":"Coordinate system representing the 1-based index in the alignment (i.e. query/ref including gaps)\n\n\n\n\n\n"},{"title":"CIGARStrings.ref_length","page":"Reference","location":"reference/#CIGARStrings.ref_length","category":"function","text":"ref_length(::AbstractCIGAR)::Int\n\nGet the number of biosymbols in the reference of the CIGAR. This is the same as the lengths of all CIGARElements of type M, D, N, = and X.\n\nSee also: query_length, aln_length\n\nExample\n\njulia> ref_length(CIGAR(\"1S5M2D6M2I5M\"))\n18\n\n\n\n\n\n"},{"title":"CIGARStrings.query_length","page":"Reference","location":"reference/#CIGARStrings.query_length","category":"function","text":"query_length(::AbstractCIGAR)::Int\n\nGet the number of biosymbols in the query of the CIGAR. This is the same as the lengths of all CIGARElements of type M, I, S, H, = and X.\n\nSee also: ref_length, aln_length\n\nExample\n\njulia> query_length(CIGAR(\"1S5M2D6M2I5M\"))\n19\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_length","page":"Reference","location":"reference/#CIGARStrings.aln_length","category":"function","text":"aln_length(::AbstractCIGAR)::Int\n\nGet the number of biosymbols spanned by the alignment of the CIGAR. Clips, padding and skips are not part of the alignment, but still part of the CIGAR. Therefore, the alignment length is the same as the lengths of all CIGARElements of type M, I, D, = and X.\n\nSee also: query_length, ref_length\n\nExample\n\njulia> aln_length(CIGAR(\"1S5M2D6M2I5M\"))\n20\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_identity","page":"Reference","location":"reference/#CIGARStrings.aln_identity","category":"function","text":"aln_identity(::AbstractCIGAR, mismatches::Int)::Float64\n\nCompute the alignment identity of the CIGAR, computed as the number of matches (not mismatches) divided by alignment length. Since the CIGAR itself may not provide information about the precise number of mismatches, the amount of mismatches is an argument. The result is always in [0.0, 1.0].\n\nExample\n\njulia> aln_identity(CIGAR(\"3M1D3M1I2M\"), 2)\n0.6\n\n\n\n\n\n"},{"title":"CIGARStrings.query_to_ref","page":"Reference","location":"reference/#CIGARStrings.query_to_ref","category":"function","text":"query_to_ref(x::AbstractCIGAR, pos::Integer)::Int\n\nGet the 1-based reference position aligning to query position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> query_to_ref(c, 4)\nTranslation(pos, 6)\n\n\n\n\n\n"},{"title":"CIGARStrings.query_to_aln","page":"Reference","location":"reference/#CIGARStrings.query_to_aln","category":"function","text":"query_to_aln(x::AbstractCIGAR, pos::Integer)::Int\n\nGet the 1-based alignment position aligning to query position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> query_to_aln(c, 8)\nTranslation(pos, 10)\n\n\n\n\n\n"},{"title":"CIGARStrings.ref_to_query","page":"Reference","location":"reference/#CIGARStrings.ref_to_query","category":"function","text":"ref_to_query(x::AbstractCIGAR, pos::Integer)::Int\n\nGet the 1-based query position aligning to reference position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> ref_to_query(c, 7)\nTranslation(pos, 9)\n\n\n\n\n\n"},{"title":"CIGARStrings.ref_to_aln","page":"Reference","location":"reference/#CIGARStrings.ref_to_aln","category":"function","text":"ref_to_aln(x::AbstractCIGAR, pos::Integer)::Int\n\nGet the 1-based alignment position aligning to reference position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> ref_to_aln(c, 7)\nTranslation(pos, 11)\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_to_query","page":"Reference","location":"reference/#CIGARStrings.aln_to_query","category":"function","text":"aln_to_query(x::AbstractCIGAR, pos::Integer)::Int\n\nGet the 1-based query position aligning to alignment position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> aln_to_query(c, 10)\nTranslation(pos, 8)\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_to_ref","page":"Reference","location":"reference/#CIGARStrings.aln_to_ref","category":"function","text":"aln_to_ref(x::AbstractCIGAR, pos::Integer)::Int\n\nGet the 1-based reference position aligning to alignment position pos. See Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> aln_to_ref(c, 9)\nTranslation(gap, 6)\n\n\n\n\n\n"},{"title":"CIGARStrings.jl","page":"Home","location":"#CIGARStrings.jl","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"CIGARStrings.jl provide functionality for parsing and working with Concise Idiosyncratic Gapped Alignment Report - or CIGAR - strings. CIGARs were popularized by the SAM format, and are a compact run length encoding notation to represent pairwise alignments. They can be found in the SAM, BAM, PAF, and GFA formats."},{"title":"Home","page":"Home","location":"","category":"page","text":"For example, the following pairwise alignment of a query to a reference:"},{"title":"Home","page":"Home","location":"","category":"page","text":"    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC"},{"title":"Home","page":"Home","location":"","category":"page","text":"Can be represented by the CIGAR 5M3D2M2I3M, representing:"},{"title":"Home","page":"Home","location":"","category":"page","text":"5 matches/mismatches\nThen, 3 deletions\nThen, 2 matches/mismatches\nThen, 2 insertions\nFinally, 3 matches/mismatches."},{"title":"Home","page":"Home","location":"","category":"page","text":"A CIGAR strings is always written in terms of the query, and not the reference. "},{"title":"Individual alignment operations","page":"Home","location":"#Individual-alignment-operations","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"One run of identical alignment operations, e.g. \"5 matches/mismatches\" are represented by a single CIGARElement. Conceptually, a CIGARElement is an alignment operation (represented by a CIGAROp) and a length:"},{"title":"CIGARStrings.CIGARElement","page":"Home","location":"#CIGARStrings.CIGARElement","category":"type","text":"CIGARElement(op::CIGAROp, len::Integer)\n\nType representing a single element in a CIGAR string, consisting of a CIGAROp and a length. For example, in 15S198M1D15M, the four elements are 15S, 198M, 1D, and 15M. Access the operation and the length with the properties .op and .len. Note that currently, the largest supported length is 268435455. Operations cannot have length zero.\n\nSee also: CIGAR, CIGAROp\n\nExamples\n\njulia> e = CIGARElement(OP_X, 3)\nCIGARElement(OP_X, 3)\n\njulia> e.len\n3\n\njulia> e.op\nOP_X\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGAROp","page":"Home","location":"#CIGARStrings.CIGAROp","category":"type","text":"CIGAROp\n\n1-byte primitive type representing a CIGAR operation. Module-level constants for each value of this type are exported, e.g. OP_M.\n\nA CIGAROp is guaranteed to be a 1-byte primitive with the same bitwise representation as a UInt8 with the value given as N in the table below, e.g. reinterpret(UInt8, OP_I) === 0x01.\n\nThe Consumes entry below signifies if the operation advances the position in the query (Q), the reference (R) and the alignment (A). E.g. if the CIGARElement 9D begins at query, ref, aln positions (A, B, C), then the positions are (A, B+9, C+9) after. \n\nN Consumes Variable Char Description\n0 Q R A OP_M M Alignment match or mismatch\n1 Q   A OP_I I Insertion relative to the reference\n2 R A OP_D D Deletion relative to the reference\n3 R OP_N N Reference skipped from the alignment (usually an intron)\n4 Q OP_S S Soft clip (semantically identical to hard clip)\n5 Q OP_H H Hard clip (semantically identical to soft clip)\n6  OP_P P Padding, position not present in query or reference\n7 Q R A OP_Eq = Alignment match, not mismatch\n8 Q R A OP_X X Alignment mismatch\n\nSee also: CIGARElement\n\nExtended help\n\nM means a match or a mismatch. By default, most programs will emit M instead of X or =, since the important part of the CIGAR is where the insertions and deletions are placed. To determine which bases in an M are matches and mismatches, the two sequences can be compared, base-wise.\nN means that the region is spans an intron, which means the query sequence is deleted, but not due to an actual deletion (which would be a D operation). It can also be used for other uses where the reference bases is missing for another reason than a deletion, if such a use case is found.\nS and H are semantically identical. They both signify the end(s) of the query sequence which are not part of the alignment. They differ only in whether the clipped bases are written in the SEQ field of a SAM record. Typically, hard-clipped bases are present as soft clipped bases in another record, such that writing them in both records would be wasteful.\nP is only used for a multiple sequence alignment. If a third sequence contains an insertion relative to both the query and the reference, the query has a P at this position, indicating it's present in neither the query nor reference.\nMost alignments only contain the operations M, I, D, S.\n\n\n\n\n\n"},{"title":"CIGARs","page":"Home","location":"#CIGARs","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"A CIGAR string is represented by an AbstractCIGAR, which currently has two subtypes: CIGAR and BAMCIGAR. These types differ in their memory layout: The former stores the CIGAR as its ASCII representation (as used in the SAM format), and the latter stores it in a binary format (as used in the BAM format). Both typs store its underlying data as an ImmutableMemoryView{UInt8}."},{"title":"CIGARStrings.AbstractCIGAR","page":"Home","location":"#CIGARStrings.AbstractCIGAR","category":"type","text":"abstract type AbstractCIGAR\n\nThis abstract type is (not yet) a defined interface. Its concrete subtypes are CIGAR and BAMCIGAR.\n\n\n\n\n\n"},{"title":"Home","page":"Home","location":"","category":"page","text":"The API for these two types are almost interchangeable, so examples below will use CIGAR, since its plaintext representation makes examples easier. See BAMCIGAR section for a list of all differences between the two types."},{"title":"Home","page":"Home","location":"","category":"page","text":"CIGAR strings are validated upon construction"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> CIGAR(\"2M1D3M\")\nCIGAR(\"2M1D3M\")\n\njulia> CIGAR(\"1M1W1S\")\nERROR: Error around byte 4: Invalid operation. Possible values are \"MIDNSHP=X\".\n[...]"},{"title":"Home","page":"Home","location":"","category":"page","text":"Since CIGAR strings occur in various bioinformatics file formats, it is expected that users of CIGARStrings.jl will construct CIGARs from a view into a buffer storing a chunk of the file."},{"title":"Home","page":"Home","location":"","category":"page","text":"This is zero-copy, and ought not to allocate (although it currently does, due to a limitation of the Julia compiler):"},{"title":"Home","page":"Home","location":"","category":"page","text":"For example:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> data = b\"some format with CIGAR: 15M9D18M etc\";\n\njulia> buffer = collect(data);\n\njulia> c = CIGAR(view(buffer, 25:32))\nCIGAR(\"15M9D18M\")"},{"title":"CIGARStrings.CIGAR","page":"Home","location":"#CIGARStrings.CIGAR","category":"type","text":"CIGAR <: AbstractCIGAR\n\nA CIGAR string represents the sequence of insertions, matches and deletions that comprise a pairwise alignment. Construct a CIGAR from any object x where MemoryView(x) returns a MemoryView{UInt8}, i.e. any memory-backed bytearray, or string.\n\nUse CIGARStrings.try_parse to attempt to parse a CIGAR string without throwing an exception if the data is invalid.\n\nSee also: CIGARElement\n\nExtended help\n\nCIGAR strings are sequences of CIGARElement, from the 5' to the 3' of the query (or N- to C-terminal for amino acids). CIGAR strings comprise the entire query, i.e. the sum of lengths of elements with the XMI=SH operations equals the length of the query.\n\nFor example, the query AGCGTAGCACACC that aligns from query base 5 and ref base 1002, like this:\n\nQ: 5    TAG--CACACC   13\nR: 1002 TAGGACAC-CC 1011\n\nIs summarized by the CIGAR 4S3M2D3M1I2M. The operations HX=PN are more rarely used, see CIGAROp for a description of the operations.\n\n\n\n\n\n"},{"title":"Home","page":"Home","location":"","category":"page","text":"CIGARs are iterable, and returns its CIGARElements, in order:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> collect(CIGAR(\"2M1D3M\"))\n3-element Vector{CIGARElement}:\n CIGARElement(OP_M, 2)\n CIGARElement(OP_D, 1)\n CIGARElement(OP_M, 3)"},{"title":"Home","page":"Home","location":"","category":"page","text":"They can be converted back to strings using string(::CIGAR), or printed into an IO, in which case their normal string representation is recovered:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> c = CIGAR(\"2M1D3M\");\n\njulia> string(c)\n\"2M1D3M\"\n\njulia> io = IOBuffer(); print(io, c); String(take!(io))\n\"2M1D3M\""},{"title":"Home","page":"Home","location":"","category":"page","text":"The memory underlying the CIGAR types can be obtained with MemoryView(x) using the MemoryViews.jl package:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> c = CIGAR(\"19M\");\n\njulia> println(MemoryView(c))\nUInt8[0x31, 0x39, 0x4d]\n\njulia> println(MemoryView(BAMCIGAR(c)))\nUInt8[0x30, 0x01, 0x00, 0x00]"},{"title":"Basic information about a CIGAR","page":"Home","location":"#Basic-information-about-a-CIGAR","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"The reference, query and alignment length can be obtained with the functions ref_length, query_length and aln_length."},{"title":"Home","page":"Home","location":"","category":"page","text":"In the alignment below, represented as 5M3D2M2I3M, the query length is 12, since there are 12 query symbols, the reference length is 13, and the alignment length is 15."},{"title":"Home","page":"Home","location":"","category":"page","text":"    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC"},{"title":"Home","page":"Home","location":"","category":"page","text":"We always have aln_length(c) â‰¥ max(query_length(c), ref_length(c))"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> c = CIGAR(\"5M3D2M2I3M\");\n\njulia> ref_length(c)\n13\n\njulia> query_length(c)\n12\n\njulia> aln_length(c)\n15"},{"title":"Home","page":"Home","location":"","category":"page","text":"The alignment identity (number of matches, not mismatches divided by alignment length) can be obtained with aln_identity. Since the number of mismatches may not be known from the CIGAR itself (i.e. \"100M\" could have anywhere from 0 to 100 mismatches), the mismatches is passed in as an argument:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> aln_identity(CIGAR(\"3M1D3M1I2M\"), 2)\n0.6"},{"title":"Position translation","page":"Home","location":"#Position-translation","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"Sometimes it may be necessary to answer questions of the form \"which reference position does query position 8 align to?\"."},{"title":"Home","page":"Home","location":"","category":"page","text":"As an example, consider the alignment below. The query position (QP), reference position (RP) and alignment position (AP) are also written in this alignment."},{"title":"Home","page":"Home","location":"","category":"page","text":"    QP:12345   6789012\n\n    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC\n\n    RP:1234567890  123\n    AP:123456789012345"},{"title":"Home","page":"Home","location":"","category":"page","text":"We can see that query position 6 aligns to reference position 9, which is also alignment position 9."},{"title":"Home","page":"Home","location":"","category":"page","text":"These position translation can be obtained using the function pos_to_pos, specifying the source and destination coordinate systems query, ref or aln. When passed an integer, this function returns Translation object that contains two properties: .pos and .kind."},{"title":"Home","page":"Home","location":"","category":"page","text":"When a position translation has a straightforward answer, the .kind property is CIGARStrings.pos, and the .pos field is the corresponding position:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> c = CIGAR(\"4M3D2M2I3M\"); # alignment above\n\njulia> pos_to_pos(query, ref, c, 6)\nTranslation(pos, 9)\n\njulia> pos_to_pos(aln, query, c, 9)\nTranslation(pos, 6)"},{"title":"Home","page":"Home","location":"","category":"page","text":"Note that these operations are in linear time, as they scan the CIGAR string from the beginning."},{"title":"Home","page":"Home","location":"","category":"page","text":"To efficiently query multiple translations in the same scan of the CIGAR string, you can pass a sorted (ascending) iterator of integers. In this case, pos_to_pos will return a lazy iterator of Pair{Int, Translation}, representing source_index => destination_index:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> c = CIGAR(\"4M3D2M2I3M\"); # alignment above\n\njulia> it = pos_to_pos(query, ref, c, [1, 5, 6, 11]);\n\njulia> length(it)\n4\n\njulia> collect(it)\n4-element Vector{Pair{Int64, Translation}}:\n  1 => Translation(pos, 1)\n  5 => Translation(pos, 8)\n  6 => Translation(pos, 9)\n 11 => Translation(pos, 12)"},{"title":"CIGARStrings.pos_to_pos","page":"Home","location":"#CIGARStrings.pos_to_pos","category":"function","text":"pos_to_pos(from::Coordinate, to::Coodinate, cigar::AbstractCIGAR, pos::Integer)::Integer\n\nSimilar to the generic pos_to_pos, but returns the resulting integer immediately instead of returning a lazy iterator.\n\n\n\n\n\npos_to_pos(\n    from::Coordinate,\n    to::Coodinate,\n    cigar::AbstractCIGAR,\n    pos\n)::PositionMapper\n\nMap positions from one coordinate system in the alignment given by cigar to another.\n\nGiven pos, an iterable of sorted (ascending) integers in the coordiate system of from, returns a PositionMapper - an iterable of Pair{Int, Translation} mapping each input integer, in order, to the correspodin coordinate system in to, given as a Translation.\n\nThe coordinates may be query, ref or aln:\n\nquery represents the 1-based index into the query sequence\nref represents the 1-based index into the reference sequence\naln is the index of the alignment itself, i.e. equivalent to the sequence of either the query or the ref when gaps according to indel operations of c.\n\nFor example, given the query positions p = [4, 9, 11] and c::AbstractCIGAR, the corresponding positions in the reference can be obtained by [i.second.pos for i in pos_to_pos(query, ref, c, p)]\n\nSee also: Translation, ref_to_query, aln_to_ref etc.\n\njulia> iter = pos_to_pos(query, ref, CIGAR(\"5M2D10M\"), [0, 4, 9, 16]);\n\njulia> iter isa CIGARStrings.PositionMapper\ntrue\n\njulia> collect(iter)\n4-element Vector{Pair{Int64, Translation}}:\n  0 => Translation(outside, 0)\n  4 => Translation(pos, 4)\n  9 => Translation(pos, 11)\n 16 => Translation(outside, 0)\n\n\n\n\n\n"},{"title":"CIGARStrings.Translation","page":"Home","location":"#CIGARStrings.Translation","category":"type","text":"Translation(kind::TranslationKind, pos::Int)\n\nThe result of translating from a position in the coordinate system of the  query / reference / alignment to a position in one of the others. This type contains two documented properies: kind::TranslationKind and pos::Int.\n\nIf the resulting position is outside the target coordinate, .kind == outside and pos == 0\nIf the position maps to a non-gap symbol in the other coodinate system, .kind == pos, and the position is the pos'd symbol in the target coordinate system.\nIf the position maps to a gap, pos is the position of the symbol before the gap, and kind == gap. When translating to the aln coordinate system, the kind is never gap.\n\nSee also: CIGARStrings.TranslationKind\n\nExamples:\n\njulia> c = CIGAR(\"2M3D2M2I1M\");\n\njulia> for i in 0:8\n           refpos = query_to_ref(c, i)\n           println(refpos.pos, ' ', refpos.kind)\n       end\n0 outside\n1 pos\n2 pos\n6 pos\n7 pos\n7 gap\n7 gap\n8 pos\n0 outside\n\n\n\n\n\n"},{"title":"CIGARStrings.TranslationKind","page":"Home","location":"#CIGARStrings.TranslationKind","category":"type","text":"TranslationKind\n\nThis enum has values outside, pos and gap. It represents the result of translating a position between query, reference and alignment.\n\nIf outside, the input position translates to a position outside the alignment\nIf pos, the input position corresponds to a non-gap symbol in the alignment\nIf gap, the input position maps to a gap.\n\nSee also: Translation\n\n\n\n\n\n"},{"title":"Errors and error recovery","page":"Home","location":"#Errors-and-error-recovery","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"CIGARStrings.jl allows you to parse a poential CIGAR string without throwing an exception if the data is invalid, using the function CIGARStrings.try_parse."},{"title":"CIGARStrings.CIGARError","page":"Home","location":"#CIGARStrings.CIGARError","category":"type","text":"CIGARError\n\nException kind thrown by the package CIGARStrings. CIGARErrors contain two properties: .kind, returning a CIGARErrorType, and .index, returning an Int, pointing to the approximate byte index where the exception was encountered.\n\nThe kind and pos are stable API, in the sense that e.g. an integer overflow at position 55 will always be represented by a CIGARError(55, CIGARStrings.Errors.IntegerOverflow). However, the same invalid CIGAR string may produce multiple different errors, and which error is produced in that case is NOT stable API, because that depends on specifics parsing internals.\n\njulia> ce = CIGARStrings.try_parse(CIGAR, \"15M9\");\n\njulia> ce.index\n4\n\njulia> ce.kind\nTruncated::CIGARErrorType = 0x05\n\n\n\n\n\n"},{"title":"CIGARStrings.Errors.CIGARErrorType","page":"Home","location":"#CIGARStrings.Errors.CIGARErrorType","category":"type","text":"CIGARErrorType\n\nSingle-byte enum representing the different kind of errors returned or thrown by the package CIGARStrings. This currently implemented list of error kinds is not exhaustive, in that more could be added in minor versions of this package.\n\nSee also: CIGARError\n\n\n\n\n\n"},{"title":"CIGARStrings.try_parse","page":"Home","location":"#CIGARStrings.try_parse","category":"function","text":"try_parse(::Type{CIGAR}, x)::Union{CIGAR, CIGARError}\n\nCast x to a MemoryView{UInt8}, and try parsing a CIGAR from it. If the parsing is unsuccessful, return a CIGARError\n\nExamples\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"2S1M9I\");\n\njulia> c isa CIGAR # success\ntrue\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"1S7H9M1S\");\n\njulia> c.kind\nInvalidHardClip::CIGARErrorType = 0x03\n\n\n\n\n\n"},{"title":"The BAMCIGAR type","page":"Home","location":"#bamcigar","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"A CIGAR in the BAM format is stored in an array of 32-bit integers. However, in order to make zero-copy CIGARs possible, the BAMCIGAR type is backed by an ImmutableMemoryView{UInt8} instead, with the same memory layout as its equivalent Memory{UInt32}."},{"title":"CIGARStrings.BAMCIGAR","page":"Home","location":"#CIGARStrings.BAMCIGAR","category":"type","text":"BAMCIGAR <: AbstractCIGAR\n\nA BAMCIGAR is an alternative representation of a CIGAR, stored compactly in 32-bit integers. Semantically, a BAMCIGAR behaves much similar to a CIGAR.\n\nConstruct a BAMCIGAR either from a CIGAR, taking an optional Vector{UInt8} to use as backing storage, or using CIGARStrings.try_parse.\n\nExamples\n\njulia> c = CIGAR(\"9S123M1=3I15M2H\");\n\njulia> b = BAMCIGAR(c, UInt8[]); # use existing storage\n\njulia> c == b\ntrue\n\njulia> CIGAR(b)\nCIGAR(\"9S123M1=3I15M2H\")\n\n\n\n\n\n"},{"title":"Home","page":"Home","location":"","category":"page","text":"A BAMCIGAR can be constructed from its binary representation, using any type which implements MemoryViews.MemoryView:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> BAMCIGAR(\"\\x54\\4\\0\\0\\x70\\4\\0\\0\")\nBAMCIGAR(CIGAR(\"69S71M\"))"},{"title":"Home","page":"Home","location":"","category":"page","text":"This is not zero-cost: Like CIGAR the type contains some metadata and is validated upon construction."},{"title":"Home","page":"Home","location":"","category":"page","text":"Like CIGAR, the try_parse function can be used:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> CIGARStrings.try_parse(BAMCIGAR, \"\\x5f\\4\\0\\0\\x70\\4\\0\\0\")\nCIGARStrings.CIGARError(1, CIGARStrings.Errors.InvalidOperation)"},{"title":"Home","page":"Home","location":"","category":"page","text":"CIGAR and BAMCIGAR can be converted ifallably to each other:"},{"title":"Home","page":"Home","location":"","category":"page","text":"julia> c = CIGAR(\"6H19S18M1I22=8I2S\");\n\njulia> b = BAMCIGAR(c);\n\njulia> b == c\ntrue\n\njulia> CIGAR(b) == c\ntrue"},{"title":"Home","page":"Home","location":"","category":"page","text":"Note that printing a BAMCIGAR allocates, because it needs to allocate a new piece of memory to store its ASCII representation. For high performance applications, the function cigar_view! may be used:"},{"title":"CIGARStrings.cigar_view!","page":"Home","location":"#CIGARStrings.cigar_view!","category":"function","text":"cigar_view!(v::Vector{UInt8}, x::BAMCIGAR)::ImmutableMemoryView{UInt8}\n\nWrite the ASCII (i.e. CIGAR) representation x into v, emptying v's original content. A memory view of v is returned:\n\nExamples\n\njulia> v = [0x01, 0x02, 0x03];\n\njulia> bc = BAMCIGAR(CIGAR(\"151M3D20M\"));\n\njulia> mem_view = cigar_view!(v, bc);\n\njulia> mem_view == v\ntrue\n\njulia> String(mem_view) == string(CIGAR(bc))\ntrue\n\n\n\n\n\n"}]
}

var documenterSearchIndex = {"docs":
[{"title":"CIGARStrings.jl reference","page":"Reference","location":"reference/#CIGARStrings.jl-reference","category":"section","text":""},{"title":"CIGARStrings.CIGAR","page":"Reference","location":"reference/#CIGARStrings.CIGAR-reference","category":"type","text":"CIGAR <: AbstractCIGAR\n\nA CIGAR string represents the sequence of insertions, matches and deletions\nthat comprise a pairwise alignment.\nConstruct a CIGAR from any object x where MemoryView(x) returns a\nMemoryView{UInt8}, i.e. any memory-backed bytearray, or string.\n\nUse CIGARStrings.try_parse to attempt to parse a CIGAR string\nwithout throwing an exception if the data is invalid.\n\nSee also: CIGARElement\n\nExtended help\n\nCIGAR strings are sequences of CIGARElement, from the 5' to the 3' of the\nquery (or N- to C-terminal for amino acids).\nCIGAR strings comprise the entire query, i.e. the sum of lengths of elements\nwith the XMI=SH operations equals the length of the query.\n\nFor example, the query AGCGTAGCACACC that aligns from query base 5 and ref\nbase 1002, like this:\n\nQ: 5    TAG--CACACC   13\nR: 1002 TAGGACAC-CC 1011\n\nIs summarized by the CIGAR 4S3M2D3M1I2M. The operations HX=PN are more rarely\nused, see CIGAROp for a description of the operations.\n\n\n\n\n\n"},{"title":"CIGARStrings.BAMCIGAR","page":"Reference","location":"reference/#CIGARStrings.BAMCIGAR-reference","category":"type","text":"BAMCIGAR <: AbstractCIGAR\n\nA BAMCIGAR is an alternative representation of a CIGAR,\nstored compactly in 32-bit integers.\nSemantically, a BAMCIGAR behaves much similar to a CIGAR.\n\nConstruct a BAMCIGAR either from a CIGAR, taking an optional Vector{UInt8}\nto use as backing storage, or using CIGARStrings.try_parse,\nor BAMCIGAR(::MutableMemoryView{UInt8}, ::CIGAR)\n\nExamples\n\njulia> c = CIGAR(\"9S123M1=3I15M2H\");\n\njulia> b = BAMCIGAR(c, UInt8[]); # use existing storage\n\njulia> c == b\ntrue\n\njulia> CIGAR(b)\nCIGAR(\"9S123M1=3I15M2H\")\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGARElement","page":"Reference","location":"reference/#CIGARStrings.CIGARElement-reference","category":"type","text":"CIGARElement(op::CIGAROp, len::Integer)\n\nType representing a single element in a CIGAR string, consisting of a\nCIGAROp and a length.\nFor example, in 15S198M1D15M, the four elements are 15S, 198M, 1D,\nand 15M.\nAccess the operation and the length with the properties .op and .len.\nNote that currently, the largest supported length is 268435455.\nOperations cannot have length zero.\n\nSee also: CIGAR, CIGAROp\n\nExamples\n\njulia> e = CIGARElement(OP_X, 3)\nCIGARElement(OP_X, 3)\n\njulia> e.len\n3\n\njulia> e.op\nOP_X\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGAROp","page":"Reference","location":"reference/#CIGARStrings.CIGAROp-reference","category":"type","text":"CIGAROp\n\n1-byte primitive type representing a CIGAR operation.\nModule-level constants for each value of this type are exported, e.g. OP_M.\n\nA CIGAROp is guaranteed to be a 1-byte primitive with the same bitwise\nrepresentation as a UInt8 with the value given as N in the table below,\ne.g. reinterpret(UInt8, OP_I) === 0x01.\n\nThe Consumes entry below signifies if the operation advances the position\nin the query (Q), the reference (R) and the alignment (A).\nE.g. if the CIGARElement 9D begins at query, ref, aln positions (A, B, C),\nthen the positions are (A, B+9, C+9) after. \n\nN Consumes Variable Char Description\n0 Q R A OP_M M Alignment match or mismatch\n1 Q   A OP_I I Insertion relative to the reference\n2 R A OP_D D Deletion relative to the reference\n3 R OP_N N Reference skipped from the alignment (usually an intron)\n4 Q OP_S S Soft clip (semantically identical to hard clip)\n5 Q OP_H H Hard clip (semantically identical to soft clip)\n6  OP_P P Padding, position not present in query or reference\n7 Q R A OP_Eq = Alignment match, not mismatch\n8 Q R A OP_X X Alignment mismatch\n\nSee also: CIGARElement\n\nExtended help\n\nM means a match or a mismatch. By default, most programs will emit M\ninstead of X or =, since the important part of the CIGAR is where the\ninsertions and deletions are placed. To determine which bases in an M\nare matches and mismatches, the two sequences can be compared, base-wise.\nN means that the region spans an intron, which means the query sequence\nis deleted, but not due to an actual deletion (which would be a D operation).\nIt can also be used for other uses where the reference bases are missing\nfor another reason than a deletion, if such a use case is found.\nS and H are semantically identical. They both signify the end(s) of the\nquery sequence which are not part of the alignment. They differ only in whether\nthe clipped bases are written in the SEQ field of a SAM record.\nTypically, hard-clipped bases are present as soft clipped bases in another\nrecord, such that writing them in both records would be wasteful.\nP is only used for a multiple sequence alignment. If a third sequence contains an\ninsertion relative to both the query and the reference, the query has a\nP at this position, indicating it's present in neither the query nor reference.\nMost alignments only contain the operations M, I, D, S.\n\n\n\n\n\n"},{"title":"CIGARStrings.Translation","page":"Reference","location":"reference/#CIGARStrings.Translation-reference","category":"type","text":"Translation(kind::TranslationKind, pos::Int)\n\nThe result of translating from a position in the coordinate system of the \nquery / reference / alignment to a position in one of the others.\nThis type contains two documented properties: kind::TranslationKind and pos::Int.\n\nIf the resulting position is outside the target coordinate, .kind == outside\nand pos == 0\nIf the position maps to a non-gap symbol in the other coordinate system,\n.kind == pos, and the position is the pos'd symbol in the target coordinate\nsystem.\nIf the position maps to a gap, pos is the position of the symbol before the\ngap, and kind == gap. When translating to the aln coordinate system,\nthe kind is never gap.\n\nSee also: CIGARStrings.TranslationKind\n\nExamples:\n\njulia> c = CIGAR(\"2M3D2M2I1M\");\n\njulia> for i in 0:8\n           refpos = query_to_ref(c, i)\n           println(refpos.pos, ' ', refpos.kind)\n       end\n0 outside\n1 pos\n2 pos\n6 pos\n7 pos\n7 gap\n7 gap\n8 pos\n0 outside\n\n\n\n\n\n"},{"title":"CIGARStrings.TranslationKind","page":"Reference","location":"reference/#CIGARStrings.TranslationKind-reference","category":"type","text":"TranslationKind\n\nThis enum has values outside, pos and gap. It represents the result of\ntranslating a position between query, reference and alignment.\n\nIf outside, the input position translates to a position outside the alignment\nIf pos, the input position corresponds to a non-gap symbol in the alignment\nIf gap, the input position maps to a gap.\n\nSee also: Translation\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGARError","page":"Reference","location":"reference/#CIGARStrings.CIGARError-reference","category":"type","text":"CIGARError\n\nException kind thrown by the package CIGARStrings.\nCIGARErrors contain two properties: .kind, returning a CIGARErrorType,\nand .index, returning an Int, pointing to the approximate byte index where the\nexception was encountered.\n\nThe kind and pos are stable API, in the sense that e.g. an integer overflow\nat position 55 will always be represented by a\nCIGARError(55, CIGARStrings.Errors.IntegerOverflow).\nHowever, the same invalid CIGAR string may produce multiple different errors, and which\nerror is produced in that case is NOT stable API, because that depends on specifics\nparsing internals.\n\njulia> ce = CIGARStrings.try_parse(CIGAR, \"15M9\");\n\njulia> ce.index\n4\n\njulia> ce.kind\nTruncated::CIGARErrorType = 0x05\n\n\n\n\n\n"},{"title":"CIGARStrings.Errors.CIGARErrorType","page":"Reference","location":"reference/#CIGARStrings.Errors.CIGARErrorType-reference","category":"type","text":"CIGARErrorType\n\nSingle-byte enum representing the different kind of errors returned or thrown by\nthe package CIGARStrings.\nThis currently implemented list of error kinds is not exhaustive, in that more\ncould be added in minor versions of this package.\n\nSee also: CIGARError\n\n\n\n\n\n"},{"title":"CIGARStrings.try_parse","page":"Reference","location":"reference/#CIGARStrings.try_parse-reference","category":"function","text":"try_parse(::Type{CIGAR}, x)::Union{CIGAR, CIGARError}\n\nCast x to a MemoryView{UInt8}, and try parsing a CIGAR from it.\nIf the parsing is unsuccessful, return a CIGARError\n\nExamples\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"2S1M9I\");\n\njulia> c isa CIGAR # success\ntrue\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"1S7H9M1S\");\n\njulia> c.kind\nInvalidHardClip::CIGARErrorType = 0x03\n\n\n\n\n\n"},{"title":"CIGARStrings.unsafe_switch_memory","page":"Reference","location":"reference/#CIGARStrings.unsafe_switch_memory","category":"function","text":"unsafe_switch_memory(cigar::T, mem::ImmutableMemoryView{UInt8})::T where {T <: AbstractCIGAR}\n\nCreate a new instance of typeof(cigar) equal to cigar, but using the new memory\nmem which must be equal to the existing memory backing cigar.\nThis operation does not do any validation.\n\nThis function is unsafe, because it assumes that mem == MemoryView(cigar).\nIf this assumption is violated, any subsequent operation on the resulting AbstractCIGAR\nmay cause undefined behaviour.\n\nExamples\n\njulia> mem = MemoryView(\"5S12M1X8M10S\");\n\njulia> cigar_1 = CIGAR(mem);\n\njulia> cigar_2 = unsafe_switch_memory(cigar_1, copy(mem));\n\njulia> cigar_1 == cigar_2\ntrue\n\njulia> MemoryView(cigar_1) === MemoryView(cigar_2)\nfalse\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_M","page":"Reference","location":"reference/#CIGARStrings.OP_M","category":"constant","text":"'M': Alignment match or mismatch\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_I","page":"Reference","location":"reference/#CIGARStrings.OP_I","category":"constant","text":"'I': Insertion relative to the reference\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_D","page":"Reference","location":"reference/#CIGARStrings.OP_D","category":"constant","text":"'D': Deletion relative to the reference\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_S","page":"Reference","location":"reference/#CIGARStrings.OP_S","category":"constant","text":"'S': Soft clip (clipped sequence present in query)\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_H","page":"Reference","location":"reference/#CIGARStrings.OP_H","category":"constant","text":"'H': Hard clip (clipped sequence not present in query)\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_N","page":"Reference","location":"reference/#CIGARStrings.OP_N","category":"constant","text":"'N': Region skipped from the reference (usually an intron)\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_P","page":"Reference","location":"reference/#CIGARStrings.OP_P","category":"constant","text":"'P': Padding\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_X","page":"Reference","location":"reference/#CIGARStrings.OP_X","category":"constant","text":"'X': Alignment mismatch\n\n\n\n\n\n"},{"title":"CIGARStrings.OP_Eq","page":"Reference","location":"reference/#CIGARStrings.OP_Eq","category":"constant","text":"'=': Alignment match, not mismatch\n\n\n\n\n\n"},{"title":"CIGARStrings.PositionMapper","page":"Reference","location":"reference/#CIGARStrings.PositionMapper","category":"type","text":"PositionMapper{Params...}\n\nPublic struct returned by pos_to_pos(..., pos) when !isa(pos, Integer).\nThis type may be referred to in stable code, but its API is defined by\npos_to_pos\n\nSee also: pos_to_pos\n\n\n\n\n\n"},{"title":"CIGARStrings.query","page":"Reference","location":"reference/#CIGARStrings.query","category":"function","text":"Coordinate system representing the 1-based index in the query sequence\n\n\n\n\n\n"},{"title":"CIGARStrings.ref","page":"Reference","location":"reference/#CIGARStrings.ref","category":"function","text":"Coordinate system representing the 1-based index in the reference sequence\n\n\n\n\n\n"},{"title":"CIGARStrings.aln","page":"Reference","location":"reference/#CIGARStrings.aln","category":"function","text":"Coordinate system representing the 1-based index in the alignment (i.e. query/ref including gaps)\n\n\n\n\n\n"},{"title":"CIGARStrings.ref_length","page":"Reference","location":"reference/#CIGARStrings.ref_length","category":"function","text":"ref_length(::AbstractCIGAR)::Int\n\nGet the number of biosymbols in the reference of the CIGAR. This is the same\nas the lengths of all CIGARElements of type M, D, N, = and X.\n\nSee also: query_length, aln_length\n\nExample\n\njulia> ref_length(CIGAR(\"1S5M2D6M2I5M\"))\n18\n\n\n\n\n\n"},{"title":"CIGARStrings.query_length","page":"Reference","location":"reference/#CIGARStrings.query_length","category":"function","text":"query_length(::AbstractCIGAR)::Int\n\nGet the number of biosymbols in the query of the CIGAR. This is the same\nas the lengths of all CIGARElements of type M, I, S, H, = and X.\n\nSee also: ref_length, aln_length\n\nExample\n\njulia> query_length(CIGAR(\"1S5M2D6M2I5M\"))\n19\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_length","page":"Reference","location":"reference/#CIGARStrings.aln_length","category":"function","text":"aln_length(::AbstractCIGAR)::Int\n\nGet the number of biosymbols spanned by the alignment of the CIGAR. Clips,\npadding and skips are not part of the alignment, but still part of the CIGAR.\nTherefore, the alignment length is the same as the lengths of all CIGARElements\nof type M, I, D, = and X.\n\nSee also: query_length, ref_length\n\nExample\n\njulia> aln_length(CIGAR(\"1S5M2D6M2I5M\"))\n20\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_identity","page":"Reference","location":"reference/#CIGARStrings.aln_identity","category":"function","text":"aln_identity(::AbstractCIGAR, mismatches::Int)::Float64\n\nCompute the alignment identity of the AbstractCIGAR,\ncomputed as the number of matches\n(not mismatches) divided by alignment length.\nSince the CIGAR itself may not provide information about the precise number of\nmismatches, the amount of mismatches is an argument.\nThe result is always in [0.0, 1.0].\n\nExample\n\njulia> aln_identity(CIGAR(\"3M1D3M1I2M\"), 2)\n0.6\n\n\n\n\n\n"},{"title":"CIGARStrings.count_matches","page":"Reference","location":"reference/#CIGARStrings.count_matches","category":"function","text":"count_matches(::AbstractCIGAR, mismatches::Integer)::Int\n\nCount the number of matches in the AbstractCIGAR, given the input number\nof mismatches.\nThe mismatches argument is necessary, because OP_M is ambiguous, and\ncan encode any combination of matches and mismatches.\n\nIf mismatches is not in X:(M+X) where M is the number of symbols\nmarked OP_M, and X the number of OP_X, throw a DomainError.\n\nExamples\n\njulia> c = CIGAR(\"3S9M2I15=6X7=10M3S\"); # 19M, 22=, 6X\n\njulia> count_matches(c, 8)\n39\n\njulia> count_matches(c, 25)\n22\n\njulia> count_matches(c, 5) # lower bound is 6\nERROR: DomainError\n[...]\n\njulia> count_matches(c, 26) # upper bound is 25\nERROR: DomainError\n[...]\n\n\n\n\n\n"},{"title":"CIGARStrings.query_to_ref","page":"Reference","location":"reference/#CIGARStrings.query_to_ref","category":"function","text":"query_to_ref(x::AbstractCIGAR, pos::Integer)::Translation\n\nGet the 1-based reference position aligning to query position pos.\nSee Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> query_to_ref(c, 4)\nTranslation(pos, 6)\n\n\n\n\n\n"},{"title":"CIGARStrings.query_to_aln","page":"Reference","location":"reference/#CIGARStrings.query_to_aln","category":"function","text":"query_to_aln(x::AbstractCIGAR, pos::Integer)::Translation\n\nGet the 1-based alignment position aligning to query position pos.\nSee Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> query_to_aln(c, 8)\nTranslation(pos, 10)\n\n\n\n\n\n"},{"title":"CIGARStrings.ref_to_query","page":"Reference","location":"reference/#CIGARStrings.ref_to_query","category":"function","text":"ref_to_query(x::AbstractCIGAR, pos::Integer)::Translation\n\nGet the 1-based query position aligning to reference position pos.\nSee Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> ref_to_query(c, 7)\nTranslation(pos, 9)\n\n\n\n\n\n"},{"title":"CIGARStrings.ref_to_aln","page":"Reference","location":"reference/#CIGARStrings.ref_to_aln","category":"function","text":"ref_to_aln(x::AbstractCIGAR, pos::Integer)::Translation\n\nGet the 1-based alignment position aligning to reference position pos.\nSee Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> ref_to_aln(c, 7)\nTranslation(pos, 11)\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_to_query","page":"Reference","location":"reference/#CIGARStrings.aln_to_query","category":"function","text":"aln_to_query(x::AbstractCIGAR, pos::Integer)::Translation\n\nGet the 1-based query position aligning to alignment position pos.\nSee Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> aln_to_query(c, 10)\nTranslation(pos, 8)\n\n\n\n\n\n"},{"title":"CIGARStrings.aln_to_ref","page":"Reference","location":"reference/#CIGARStrings.aln_to_ref","category":"function","text":"aln_to_ref(x::AbstractCIGAR, pos::Integer)::Translation\n\nGet the 1-based reference position aligning to alignment position pos.\nSee Translation for more details.\n\nExamples\n\njulia> c = CIGAR(\"3M2D1M4I2M\");\n\njulia> aln_to_ref(c, 9)\nTranslation(gap, 6)\n\n\n\n\n\n"},{"title":"CIGARStrings.jl","page":"Home","location":"#CIGARStrings.jl","category":"section","text":"CIGARStrings.jl provide functionality for parsing and working with Concise Idiosyncratic Gapped Alignment Report - or CIGAR - strings.\nCIGARs were popularized by the SAM format, and are a compact run length encoding notation to represent pairwise alignments.\nThey can be found in the SAM, BAM, PAF, and GFA formats.\n\nFor example, the following pairwise alignment of a query to a reference:\n\n    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC\n\nCan be represented by the CIGAR 5M3D2M2I3M, representing:\n\n5 matches/mismatches\nThen, 3 deletions\nThen, 2 matches/mismatches\nThen, 2 insertions\nFinally, 3 matches/mismatches.\n\nA CIGAR strings is always written in terms of the query, and not the reference. "},{"title":"Individual alignment operations","page":"Home","location":"#Individual-alignment-operations","category":"section","text":"One run of identical alignment operations, e.g. \"5 matches/mismatches\" are represented\nby a single CIGARElement.\nConceptually, a CIGARElement is an alignment operation (represented by a CIGAROp) and a length:"},{"title":"CIGARs","page":"Home","location":"#CIGARs","category":"section","text":"A CIGAR string is represented by an AbstractCIGAR, which currently has two subtypes: CIGAR and BAMCIGAR.\nThese types differ in their memory layout: The former stores the CIGAR as its ASCII representation (as used in the SAM format), and the latter stores it in a binary format (as used in the BAM format).\nBoth typs store its underlying data as an ImmutableMemoryView{UInt8}.\n\nThe API for these two types are almost interchangeable, so examples below will use CIGAR, since its plaintext representation makes examples easier.\nSee BAMCIGAR section for a list of all differences between the two types.\n\nCIGAR strings are validated upon construction\n\njulia> CIGAR(\"2M1D3M\")\nCIGAR(\"2M1D3M\")\n\njulia> CIGAR(\"1M1W1S\")\nERROR: Error around byte 4: Invalid operation. Possible values are \"MIDNSHP=X\".\n[...]\n\nSince CIGAR strings occur in various bioinformatics file formats, it is expected\nthat users of CIGARStrings.jl will construct CIGARs from a view into a buffer storing a chunk of the file.\n\nThis is zero-copy, and will not to allocate on Julia 1.14 and forward.\nFor example:\n\njulia> data = b\"some format with CIGAR: 15M9D18M etc\";\n\njulia> buffer = collect(data);\n\njulia> c = CIGAR(view(buffer, 25:32))\nCIGAR(\"15M9D18M\")\n\nCIGARs are iterable, and returns its CIGARElements, in order:\n\njulia> collect(CIGAR(\"2M1D3M\"))\n3-element Vector{CIGARElement}:\n CIGARElement(OP_M, 2)\n CIGARElement(OP_D, 1)\n CIGARElement(OP_M, 3)\n\nThey can be converted back to strings using string(::CIGAR), or printed into\nan IO, in which case their normal string representation is recovered:\n\njulia> c = CIGAR(\"2M1D3M\");\n\njulia> string(c)\n\"2M1D3M\"\n\njulia> io = IOBuffer(); print(io, c); String(take!(io))\n\"2M1D3M\"\n\nThe memory underlying the CIGAR types can be obtained with MemoryView(x) using the MemoryViews.jl package:\n\njulia> c = CIGAR(\"19M\");\n\njulia> println(MemoryView(c))\nUInt8[0x31, 0x39, 0x4d]\n\njulia> println(MemoryView(BAMCIGAR(c)))\nUInt8[0x30, 0x01, 0x00, 0x00]"},{"title":"Basic information about a CIGAR","page":"Home","location":"#Basic-information-about-a-CIGAR","category":"section","text":"The reference, query and alignment length can be obtained with the functions\nref_length, query_length and aln_length.\n\nIn the alignment below, represented as 5M3D2M2I3M, the query length is\n12, since there are 12 query symbols, the reference length is 13, and the\nalignment length is 15.\n\n    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC\n\nWe always have aln_length(c) â‰¥ max(query_length(c), ref_length(c))\n\njulia> c = CIGAR(\"5M3D2M2I3M\");\n\njulia> ref_length(c)\n13\n\njulia> query_length(c)\n12\n\njulia> aln_length(c)\n15\n\nSince the CIGAR operation M (OP_M) is ambiguous to whether is represents matches,\nmismatches, or a combination of these, the function count_matches can be used to\ncount the number of matches in a CIGAR given the number of mismatches.\n\nThe number of mismatches are typically output by mappers, making this information\nhandily accessible:\n\nThe alignment identity (number of matches, not mismatches divided by alignment length)\ncan be obtained with aln_identity.\nLike count_matches, this takes the number of mismatches as an argument:"},{"title":"Comparing CIGARs","page":"Home","location":"#Comparing-CIGARs","category":"section","text":"When comparing CIGARs using ==, it will check if the CIGARs are literally identical, in the\nsense that they are composed of the same bytes:\n\njulia> c1 = CIGAR(\"10M\");\n\njulia> c2 = CIGAR(\"4=1X5=\");\n\njulia> c3 = CIGAR(\"10M\");\n\njulia> c1 == c2\nfalse\n\njulia> c1 == c3\ntrue\n\nHowever, in the above example, since the CIGAR operation M signifies a match or a mismatch, all three\nCIGARs are indeed compatible, since 10M is also a valid CIGAR annotation for the same alignment\nas 4=1X5=.\n\nThis notion of compatibility tested with is_compatible:\n\njulia> is_compatible(c1, c2)\ntrue\n\njulia> is_compatible(CIGAR(\"1X1M\"), CIGAR(\"1=1M\"))\nfalse"},{"title":"Position translation","page":"Home","location":"#Position-translation","category":"section","text":"Sometimes it may be necessary to answer questions of the form\n\"which reference position does query position 8 align to?\".\n\nAs an example, consider the alignment below.\nThe query position (QP), reference position (RP) and alignment position (AP)\nare also written in this alignment.\n\n    QP:12345   6789012\n\n    Q: TAGAT---TAGCTAC\n       ||||    ||  | |\n    R: TAGAACCATA--TGC\n\n    RP:1234567890  123\n    AP:123456789012345\n\nWe can see that query position 6 aligns to reference position 9, which is also\nalignment position 9.\n\nThese position translation can be obtained using the function pos_to_pos,\nspecifying the source and destination coordinate systems query, ref\nor aln.\nWhen passed an integer, this function returns Translation object that contains two properties: .pos and .kind.\n\nWhen a position translation has a straightforward answer, the .kind property is\nCIGARStrings.pos, and the .pos field is the corresponding position:\n\njulia> c = CIGAR(\"4M3D2M2I3M\"); # alignment above\n\njulia> pos_to_pos(query, ref, c, 6)\nTranslation(pos, 9)\n\njulia> pos_to_pos(aln, query, c, 9)\nTranslation(pos, 6)\n\nNote that these operations are in linear time, as they scan the CIGAR string from the beginning.\n\nTo efficiently query multiple translations in the same scan of the CIGAR string, you can pass a sorted (ascending) iterator of integers.\nIn this case, pos_to_pos will return a lazy iterator of Pair{Int, Translation}, representing source_index => destination_index:\n\njulia> c = CIGAR(\"4M3D2M2I3M\"); # alignment above\n\njulia> it = pos_to_pos(query, ref, c, [1, 5, 6, 11]);\n\njulia> length(it)\n4\n\njulia> collect(it)\n4-element Vector{Pair{Int64, Translation}}:\n  1 => Translation(pos, 1)\n  5 => Translation(pos, 8)\n  6 => Translation(pos, 9)\n 11 => Translation(pos, 12)"},{"title":"Errors and error recovery","page":"Home","location":"#Errors-and-error-recovery","category":"section","text":"CIGARStrings.jl allows you to parse a poential CIGAR string without throwing an exception if the data is invalid, using the function CIGARStrings.try_parse."},{"title":"The BAMCIGAR type","page":"Home","location":"#bamcigar","category":"section","text":"A CIGAR in the BAM format is stored in an array of 32-bit integers.\nHowever, in order to make zero-copy CIGARs possible, the BAMCIGAR type is backed by an ImmutableMemoryView{UInt8} instead, with the same memory layout as its equivalent Memory{UInt32}.\n\nA BAMCIGAR can be constructed from its binary representation, using any type which implements MemoryViews.MemoryView:\n\njulia> BAMCIGAR(\"\\x54\\4\\0\\0\\x70\\4\\0\\0\")\nBAMCIGAR(CIGAR(\"69S71M\"))\n\nThis is not zero-cost: Like CIGAR the type contains some metadata and is validated upon construction.\n\nLike CIGAR, the try_parse function can be used:\n\njulia> CIGARStrings.try_parse(BAMCIGAR, \"\\x5f\\4\\0\\0\\x70\\4\\0\\0\")\nCIGARStrings.CIGARError(1, CIGARStrings.Errors.InvalidOperation)\n\nCIGAR and BAMCIGAR can be converted ifallably to each other:\n\njulia> c = CIGAR(\"6H19S18M1I22=8I2S\");\n\njulia> b = BAMCIGAR(c);\n\njulia> b == c\ntrue\n\njulia> CIGAR(b) == c\ntrue\n\nNote that printing a BAMCIGAR allocates, because it needs to allocate a new piece of memory to store its ASCII representation.\nFor high performance applications, the function cigar_view! may be used:"},{"title":"CIGARStrings.CIGARElement","page":"Home","location":"#CIGARStrings.CIGARElement","category":"type","text":"CIGARElement(op::CIGAROp, len::Integer)\n\nType representing a single element in a CIGAR string, consisting of a\nCIGAROp and a length.\nFor example, in 15S198M1D15M, the four elements are 15S, 198M, 1D,\nand 15M.\nAccess the operation and the length with the properties .op and .len.\nNote that currently, the largest supported length is 268435455.\nOperations cannot have length zero.\n\nSee also: CIGAR, CIGAROp\n\nExamples\n\njulia> e = CIGARElement(OP_X, 3)\nCIGARElement(OP_X, 3)\n\njulia> e.len\n3\n\njulia> e.op\nOP_X\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGAROp","page":"Home","location":"#CIGARStrings.CIGAROp","category":"type","text":"CIGAROp\n\n1-byte primitive type representing a CIGAR operation.\nModule-level constants for each value of this type are exported, e.g. OP_M.\n\nA CIGAROp is guaranteed to be a 1-byte primitive with the same bitwise\nrepresentation as a UInt8 with the value given as N in the table below,\ne.g. reinterpret(UInt8, OP_I) === 0x01.\n\nThe Consumes entry below signifies if the operation advances the position\nin the query (Q), the reference (R) and the alignment (A).\nE.g. if the CIGARElement 9D begins at query, ref, aln positions (A, B, C),\nthen the positions are (A, B+9, C+9) after. \n\nN Consumes Variable Char Description\n0 Q R A OP_M M Alignment match or mismatch\n1 Q   A OP_I I Insertion relative to the reference\n2 R A OP_D D Deletion relative to the reference\n3 R OP_N N Reference skipped from the alignment (usually an intron)\n4 Q OP_S S Soft clip (semantically identical to hard clip)\n5 Q OP_H H Hard clip (semantically identical to soft clip)\n6  OP_P P Padding, position not present in query or reference\n7 Q R A OP_Eq = Alignment match, not mismatch\n8 Q R A OP_X X Alignment mismatch\n\nSee also: CIGARElement\n\nExtended help\n\nM means a match or a mismatch. By default, most programs will emit M\ninstead of X or =, since the important part of the CIGAR is where the\ninsertions and deletions are placed. To determine which bases in an M\nare matches and mismatches, the two sequences can be compared, base-wise.\nN means that the region spans an intron, which means the query sequence\nis deleted, but not due to an actual deletion (which would be a D operation).\nIt can also be used for other uses where the reference bases are missing\nfor another reason than a deletion, if such a use case is found.\nS and H are semantically identical. They both signify the end(s) of the\nquery sequence which are not part of the alignment. They differ only in whether\nthe clipped bases are written in the SEQ field of a SAM record.\nTypically, hard-clipped bases are present as soft clipped bases in another\nrecord, such that writing them in both records would be wasteful.\nP is only used for a multiple sequence alignment. If a third sequence contains an\ninsertion relative to both the query and the reference, the query has a\nP at this position, indicating it's present in neither the query nor reference.\nMost alignments only contain the operations M, I, D, S.\n\n\n\n\n\n"},{"title":"CIGARStrings.AbstractCIGAR","page":"Home","location":"#CIGARStrings.AbstractCIGAR","category":"type","text":"abstract type AbstractCIGAR\n\nThis abstract type is (not yet) a defined interface.\nIts concrete subtypes are CIGAR and BAMCIGAR.\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGAR","page":"Home","location":"#CIGARStrings.CIGAR","category":"type","text":"CIGAR <: AbstractCIGAR\n\nA CIGAR string represents the sequence of insertions, matches and deletions\nthat comprise a pairwise alignment.\nConstruct a CIGAR from any object x where MemoryView(x) returns a\nMemoryView{UInt8}, i.e. any memory-backed bytearray, or string.\n\nUse CIGARStrings.try_parse to attempt to parse a CIGAR string\nwithout throwing an exception if the data is invalid.\n\nSee also: CIGARElement\n\nExtended help\n\nCIGAR strings are sequences of CIGARElement, from the 5' to the 3' of the\nquery (or N- to C-terminal for amino acids).\nCIGAR strings comprise the entire query, i.e. the sum of lengths of elements\nwith the XMI=SH operations equals the length of the query.\n\nFor example, the query AGCGTAGCACACC that aligns from query base 5 and ref\nbase 1002, like this:\n\nQ: 5    TAG--CACACC   13\nR: 1002 TAGGACAC-CC 1011\n\nIs summarized by the CIGAR 4S3M2D3M1I2M. The operations HX=PN are more rarely\nused, see CIGAROp for a description of the operations.\n\n\n\n\n\n"},{"title":"CIGARStrings.is_compatible","page":"Home","location":"#CIGARStrings.is_compatible","category":"function","text":"is_compatible(a::AbstractCIGAR, b::AbstractCIGAR)::Bool\n\nCheck if a and b may refer to the same alignment.\n\nTwo distinct CIGARs may refer to the same alignment, because there are multiple\nways to annotate the same alignment. In particular, the following rules are used\nwhen determining if distinct CIGAR operations are equivalent:\n\nTwo consecutive of the same operations may be collapsed, ex: 1M1M and 2M\nAn OP_M can encompass both OP_X and OP_Eq, ex: 3M and 1X1M1=\nOP_S and OP_H are semantically identical, ex: 2S and 2H \nOP_P has no semantic meaning and is skipped: 1D1P2D1M3P and 3D1M\n\nExamples:\n\njulia> is_compatible(CIGAR(\"1=\"), CIGAR(\"1X\"))\nfalse\n\njulia> is_compatible(CIGAR(\"1D1D1D\"), CIGAR(\"3D\"))\ntrue\n\njulia> is_compatible(CIGAR(\"1D2M3I\"), CIGAR(\"1D1X1M3I\"))\ntrue\n\n\n\n\n\n"},{"title":"CIGARStrings.pos_to_pos","page":"Home","location":"#CIGARStrings.pos_to_pos","category":"function","text":"pos_to_pos(from::Coordinate, to::Coordinate, cigar::AbstractCIGAR, pos::Integer)::Integer\n\nSimilar to the generic pos_to_pos, but returns the resulting integer immediately instead of returning\na lazy iterator.\n\n\n\n\n\npos_to_pos(\n    from::Coordinate,\n    to::Coordinate,\n    cigar::AbstractCIGAR,\n    pos\n)::PositionMapper\n\nMap positions from one coordinate system in the alignment given by cigar to another.\n\nGiven pos, an iterable of sorted (ascending) integers in the coordinate system of from,\nreturns a PositionMapper - an iterable of Pair{Int, Translation} mapping each input integer,\nin order, to the corresponding coordinate system in to, given as a Translation.\n\nThe coordinates may be query, ref or aln:\n\nquery represents the 1-based index into the query sequence\nref represents the 1-based index into the reference sequence\naln is the index of the alignment itself, i.e. equivalent to the sequence of\neither the query or the ref when gaps according to indel operations of c.\n\nFor example, given the query positions p = [4, 9, 11] and c::AbstractCIGAR, the corresponding\npositions in the reference can be obtained by [i.second.pos for i in pos_to_pos(query, ref, c, p)]\n\nSee also: Translation, ref_to_query, aln_to_ref etc.\n\njulia> iter = pos_to_pos(query, ref, CIGAR(\"5M2D10M\"), [0, 4, 9, 16]);\n\njulia> iter isa CIGARStrings.PositionMapper\ntrue\n\njulia> collect(iter)\n4-element Vector{Pair{Int64, Translation}}:\n  0 => Translation(outside, 0)\n  4 => Translation(pos, 4)\n  9 => Translation(pos, 11)\n 16 => Translation(outside, 0)\n\n\n\n\n\n"},{"title":"CIGARStrings.Translation","page":"Home","location":"#CIGARStrings.Translation","category":"type","text":"Translation(kind::TranslationKind, pos::Int)\n\nThe result of translating from a position in the coordinate system of the \nquery / reference / alignment to a position in one of the others.\nThis type contains two documented properties: kind::TranslationKind and pos::Int.\n\nIf the resulting position is outside the target coordinate, .kind == outside\nand pos == 0\nIf the position maps to a non-gap symbol in the other coordinate system,\n.kind == pos, and the position is the pos'd symbol in the target coordinate\nsystem.\nIf the position maps to a gap, pos is the position of the symbol before the\ngap, and kind == gap. When translating to the aln coordinate system,\nthe kind is never gap.\n\nSee also: CIGARStrings.TranslationKind\n\nExamples:\n\njulia> c = CIGAR(\"2M3D2M2I1M\");\n\njulia> for i in 0:8\n           refpos = query_to_ref(c, i)\n           println(refpos.pos, ' ', refpos.kind)\n       end\n0 outside\n1 pos\n2 pos\n6 pos\n7 pos\n7 gap\n7 gap\n8 pos\n0 outside\n\n\n\n\n\n"},{"title":"CIGARStrings.TranslationKind","page":"Home","location":"#CIGARStrings.TranslationKind","category":"type","text":"TranslationKind\n\nThis enum has values outside, pos and gap. It represents the result of\ntranslating a position between query, reference and alignment.\n\nIf outside, the input position translates to a position outside the alignment\nIf pos, the input position corresponds to a non-gap symbol in the alignment\nIf gap, the input position maps to a gap.\n\nSee also: Translation\n\n\n\n\n\n"},{"title":"CIGARStrings.CIGARError","page":"Home","location":"#CIGARStrings.CIGARError","category":"type","text":"CIGARError\n\nException kind thrown by the package CIGARStrings.\nCIGARErrors contain two properties: .kind, returning a CIGARErrorType,\nand .index, returning an Int, pointing to the approximate byte index where the\nexception was encountered.\n\nThe kind and pos are stable API, in the sense that e.g. an integer overflow\nat position 55 will always be represented by a\nCIGARError(55, CIGARStrings.Errors.IntegerOverflow).\nHowever, the same invalid CIGAR string may produce multiple different errors, and which\nerror is produced in that case is NOT stable API, because that depends on specifics\nparsing internals.\n\njulia> ce = CIGARStrings.try_parse(CIGAR, \"15M9\");\n\njulia> ce.index\n4\n\njulia> ce.kind\nTruncated::CIGARErrorType = 0x05\n\n\n\n\n\n"},{"title":"CIGARStrings.Errors.CIGARErrorType","page":"Home","location":"#CIGARStrings.Errors.CIGARErrorType","category":"type","text":"CIGARErrorType\n\nSingle-byte enum representing the different kind of errors returned or thrown by\nthe package CIGARStrings.\nThis currently implemented list of error kinds is not exhaustive, in that more\ncould be added in minor versions of this package.\n\nSee also: CIGARError\n\n\n\n\n\n"},{"title":"CIGARStrings.try_parse","page":"Home","location":"#CIGARStrings.try_parse","category":"function","text":"try_parse(::Type{CIGAR}, x)::Union{CIGAR, CIGARError}\n\nCast x to a MemoryView{UInt8}, and try parsing a CIGAR from it.\nIf the parsing is unsuccessful, return a CIGARError\n\nExamples\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"2S1M9I\");\n\njulia> c isa CIGAR # success\ntrue\n\njulia> c = CIGARStrings.try_parse(CIGAR, \"1S7H9M1S\");\n\njulia> c.kind\nInvalidHardClip::CIGARErrorType = 0x03\n\n\n\n\n\n"},{"title":"CIGARStrings.BAMCIGAR","page":"Home","location":"#CIGARStrings.BAMCIGAR","category":"type","text":"BAMCIGAR <: AbstractCIGAR\n\nA BAMCIGAR is an alternative representation of a CIGAR,\nstored compactly in 32-bit integers.\nSemantically, a BAMCIGAR behaves much similar to a CIGAR.\n\nConstruct a BAMCIGAR either from a CIGAR, taking an optional Vector{UInt8}\nto use as backing storage, or using CIGARStrings.try_parse,\nor BAMCIGAR(::MutableMemoryView{UInt8}, ::CIGAR)\n\nExamples\n\njulia> c = CIGAR(\"9S123M1=3I15M2H\");\n\njulia> b = BAMCIGAR(c, UInt8[]); # use existing storage\n\njulia> c == b\ntrue\n\njulia> CIGAR(b)\nCIGAR(\"9S123M1=3I15M2H\")\n\n\n\n\n\n"},{"title":"CIGARStrings.BAMCIGAR","page":"Home","location":"#CIGARStrings.BAMCIGAR-Tuple{MemoryViews.MutableMemoryView{UInt8}, CIGAR}","category":"method","text":"BAMCIGAR(mem::MutableMemoryView{UInt8}, x::CIGAR)::BAMCIGAR\n\nConstruct a BAMCIGAR equal to x, using the memory mem.\nAfter calling this, mem may not be mutated, and is considered\nowned by the resulting BAMCIGAR.\n\nThrow a BoundsError if length(mem) < 4 * length(x).\n\nExamples\n\njulia> x = CIGAR(\"150M3D9S\");\n\njulia> mem = MemoryView(zeros(UInt8, 15));\n\njulia> cigar = BAMCIGAR(mem, x)\nBAMCIGAR(CIGAR(\"150M3D9S\"))\n\njulia> parent(MemoryView(cigar)) === parent(mem)\ntrue\n\n\n\n\n\n"},{"title":"CIGARStrings.cigar_view!","page":"Home","location":"#CIGARStrings.cigar_view!","category":"function","text":"cigar_view!(v::Vector{UInt8}, x::BAMCIGAR)::ImmutableMemoryView{UInt8}\n\nWrite the ASCII (i.e. CIGAR) representation x into v,\nemptying v's original content.\nA memory view of v is returned:\n\nExamples\n\njulia> v = [0x01, 0x02, 0x03];\n\njulia> bc = BAMCIGAR(CIGAR(\"151M3D20M\"));\n\njulia> mem_view = cigar_view!(v, bc);\n\njulia> mem_view == v\ntrue\n\njulia> String(mem_view) == string(CIGAR(bc))\ntrue\n\n\n\n\n\n"}]
}
